import util from 'util'
// enums from spine runtime
const BlendMode = ['normal', 'additive', 'multiply', 'screen'];
const TransformMode = ['normal', 'onlyTranslation', 'noRotationOrReflection', 'noScale', 'noScaleOrReflection'];
const PositionMode = ['fixed', 'percent'];
const SpacingMode = ['length', 'fixed', 'percent', 'proportional'];
const RotateMode = ['tangent', 'chain', 'chainScale'];
const AttachmentType = ['region', 'boundingbox', 'mesh', 'linkedmesh', 'path', 'point', 'clipping'];

function SkeletonBinary() {
    this.data = null;
    this.scale = 1;
    this.json = {};
    this.nextNum = 0;
    this.chars = null;
}

SkeletonBinary.prototype = {
    data: null,
    scale: 0x1,
    json: {},
    nextNum: 0x0,
    chars: null,
    readByte: function () {
        return this.nextNum < this.data.length ? this.data[this.nextNum++] : null;
    },
    readBoolean: function () {
        return this.readByte() != 0x0;
    },
    readShort: function () {
        return this.readByte() << 0x8 | this.readByte();
    },
    readInt: function (optimizePositive) {
        if (typeof optimizePositive === 'undefined') {
            return this.readByte() << 0x18 | this.readByte() << 0x10 | this.readByte() << 0x8 | this.readByte();
        }
        let b = this.readByte();
        let result = b & 0x7f;
        if ((b & 0x80) != 0x0) {
            b = this.readByte();
            result |= (b & 0x7f) << 0x7;
            if ((b & 0x80) != 0x0) {
                b = this.readByte();
                result |= (b & 0x7f) << 0xe;
                if ((b & 0x80) != 0x0) {
                    b = this.readByte();
                    result |= (b & 0x7f) << 0x15;
                    if ((b & 0x80) != 0x0) {
                        b = this.readByte();
                        result |= (b & 0x7f) << 0x1c;
                    }
                }
            }
        }
        return optimizePositive ? result : result >> 0x1 ^ -(result & 0x1);
    },
    bytes2Float32: function (bytes) {
        let sign = bytes & 0x80000000 ? -0x1 : 0x1;
        let exponent = (bytes >> 0x17 & 0xff) - 0x7f;
        let significand = bytes & ~(-0x1 << 0x17);
        if (exponent == 0x80)
            return sign * (significand ? Number.NaN : Number.POSITIVE_INFINITY);
        if (exponent == -0x7f) {
            if (significand == 0x0)
                return sign * 0x0;
            exponent = -0x7e;
            significand /= 0x1 << 0x16;
        } else
            significand = (significand | 0x1 << 0x17) / (0x1 << 0x17);
        return sign * significand * Math.pow(0x2, exponent);
    },
    readFloat: function () {
        let val = this.bytes2Float32((this.readByte() << 0x18) + (this.readByte() << 0x10) + (this.readByte() << 0x8) + (this.readByte() << 0x0));
    
        return parseFloat(val.toFixed(4));
    },
    readVertices: function (vertexCount) {
        let verticesLength = vertexCount << 0x1;
        if (!this.readBoolean()) {
            let vertices = this.readFloatArray(verticesLength, this.scale);
            let result = {
                full: vertices,
                numVertices: verticesLength,
                numBones: 0
            }
            return result;
        }
        let resArray = new Array();
        let bones = new Array();
        let weights = new Array();
        // [nBones in group][bone id][weights(3)]
        // e.g [2][192][0.1, 0.3, 0.5][1][192][15,16,17]
        for (let i = 0x0; i < vertexCount; i++) {
            let boneCount = this.readInt(!![]);
            resArray.push(boneCount);
            bones.push(boneCount);
            for (let j = 0x0; j < boneCount; j++) {
                let v1 = this.readInt(!![]);
                let f1 = this.readFloat() * this.scale;
                let f2 = this.readFloat() * this.scale;
                let f3 = this.readFloat() * this.scale;
                resArray.push(v1, f1, f2, f3);
                bones.push(v1);
                weights.push(f1, f2, f3);
            }
        }
        // export object, but put vertex count as a separate integer for downstream processing
        let result = {
            full: resArray,
            numVertices: weights.length,
            numBones: bones.length
        }
        return result;
    },
    readFloatArray: function (length, scale) {
        let array = new Array(length);
        if (scale == 0x1) {
            for (let i = 0x0; i < length; i++) {
                array[i] = this.readFloat();
            }
        } else {
            for (let i = 0x0; i < length; i++) {
                array[i] = this.readFloat() * scale;
            }
        }
        return array;
    },
    readShortArray: function () {
        let n = this.readInt(!![]);
        let array = new Array(n);
        for (let i = 0x0; i < n; i++) {
            array[i] = this.readShort();
        }
        return array;
    },
    readIntArray: function () {
        let n = this.readInt(!![]);
        let array = new Array(n);
        for (let i = 0x0; i < n; i++)
            array[i] = this.readInt(!![]);
        return array;
    },
    readHex: function () {
        let hex = this.readByte().toString(0x10);
        return hex.length == 0x2 ? hex : '0' + hex;
    },
    readColor: function () {
        return this.readHex() + this.readHex() + this.readHex() + this.readHex();
    },
    readString: function () {
        let charCount = this.readInt(this, !![]);
        switch (charCount) {
            case 0x0:
                return null;
            case 0x1:
                return '';
        }
        charCount--;
        this.chars = '';
        let charIndex = 0x0;
        for (let i = 0x0; i < charCount;) {
            charIndex = this.readByte();
            switch (charIndex >> 0x4) {
                case 0xc:
                case 0xd:
                    this.chars += String.fromCharCode((charIndex & 0x1f) << 0x6 | this.readByte() & 0x3f);
                    i += 0x2;
                    break;
                case 0xe:
                    this.chars += String.fromCharCode((charIndex & 0xf) << 0xc | (this.readByte() & 0x3f) << 0x6 | this.readByte() & 0x3f);
                    i += 0x3;
                    break;
                default:
                    this.chars += String.fromCharCode(charIndex);
                    i++;
            }
        }
        return this.chars;
    },
    readStringRef: function () {
        let index = this.readInt(true)
        return index === 0 ? null : this.strings[index - 1]
    },
    initJson: function () {
        this.json.skeleton = {};
        let skeleton = this.json.skeleton;
        // v4 hash -> long
        let lowHash = this.readInt() >>> 0
        let highHash = this.readInt() >>> 0
        skeleton.hash = Buffer.from(lowHash.toString(16) + highHash.toString(16)).toString('base64')
        if (skeleton.hash.length == 0x0)
            skeleton.hash = null;
        skeleton.spine = this.readString();
        if (skeleton.spine.length == 0x0)
            skeleton.spine = null;
        skeleton.x = this.readFloat();
        skeleton.y = this.readFloat();

        // width and height fields not needed for some reason
        //skeleton.width = this.readFloat();
        //skeleton.height = this.readFloat();
        this.readFloat();
        this.readFloat();

        let nonessential = this.readBoolean();
        if (nonessential) {
            skeleton.fps = this.readFloat();
            skeleton.images = this.readString();
            if (skeleton.images.length == 0x0)
                skeleton.images = null;
            skeleton.audio = this.readString();
            if (skeleton.audio.length == 0x0)
                skeleton.audio = null;
        }

        // STRINGS - v4
        this.strings = new Array(this.readInt(true))
        let strings = this.strings
        for (let i = 0x0; i < strings.length; i++) {
            strings[i] = this.readString()
        }

        // BONES - v4
        this.json.bones = new Array(this.readInt(!![]));
        let bones = this.json.bones;
        for (let i = 0x0; i < bones.length; i++) {
            let boneData = {};
            boneData.name = this.readString();
            boneData.parent = null;
            if (i != 0x0) {
                boneData.parent = bones[this.readInt(true)].name;
            }
            boneData.rotation = this.readFloat();
            boneData['x'] = this.readFloat() * this.scale;
            boneData['y'] = this.readFloat() * this.scale;
            boneData.scaleX = this.readFloat();
            boneData.scaleY = this.readFloat();
            boneData.shearX = this.readFloat();
            boneData.shearY = this.readFloat();
            boneData.length = this.readFloat() * this.scale;
            boneData.transform = TransformMode[this.readInt(!![])];
            boneData.skin = this.readBoolean();
            if (nonessential) {
                boneData.color = this.readColor();
            }

            // cleanup keys to match actual exported json
            if(boneData.parent === null) delete(boneData.parent);
            if (boneData.rotation === 0) delete (boneData.rotation)
            if (boneData['x'] === 0) delete (boneData['x'])
            if (boneData['y'] === 0) delete (boneData['y'])
            if (boneData.scaleX === 1) delete (boneData.scaleX)
            if (boneData.scaleY === 1) delete (boneData.scaleY)
            if (boneData.shearX === 0) delete (boneData.shearX)
            if (boneData.shearY === 0) delete (boneData.shearY)
            if (boneData.length === 0) delete (boneData.length)
            if (boneData.transform === "normal") delete(boneData.transform);
            if (boneData.skin === false) delete (boneData.skin)

            bones[i] = boneData;
        }

        // SLOTS - v4
        this.json.slots = new Array(this.readInt(!![]));
        let slots = this.json.slots;
        for (let i = 0x0; i < slots.length; i++) {
            let slotData = {};
            slotData.name = this.readString();
            const boneData = this.json.bones[this.readInt(!![])];
            slotData.bone = boneData.name;
            slotData.color = this.readColor();
            slotData.dark = this.readInt();
            slotData.attachment = this.readStringRef();
            slotData.blend = BlendMode[this.readInt(!![])];

            // cleanup keys to match actual exported json
            if (slotData.color === 'ffffffff') delete (slotData.color);
            if (slotData.dark === -1) delete (slotData.dark);
            if (slotData.attachment === null) delete (slotData.attachment);
            if (slotData.blend === 'normal') delete (slotData.blend);

            slots[i] = slotData;
        }

        // IK
        this.json['ik'] = new Array(this.readInt(!![]));
        let ik = this.json['ik'];
        for (let i = 0x0; i < ik.length; i++) {
            let ikConstraints = {};
            ikConstraints.name = this.readString();
            ikConstraints.order = this.readInt(!![]);
            ikConstraints.skin = this.readBoolean();
            ikConstraints.bones = new Array(this.readInt(!![]));
            for (let j = 0x0; j < ikConstraints.bones.length; j++) {
                ikConstraints.bones[j] = this.json.bones[this.readInt(!![])].name;
            }
            ikConstraints.target = this.json.bones[this.readInt(!![])].name;
            ikConstraints.mix = this.readFloat();
            ikConstraints.softness = this.readFloat() * this.scale;
            ikConstraints.bendPositive = this.readByte() != 0xff;
            ikConstraints.compress = this.readBoolean();
            ikConstraints.stretch = this.readBoolean();
            ikConstraints.uniform = this.readBoolean();

            // cleanup keys to match actual exported json
            if (ikConstraints.order === 0) delete (ikConstraints.order);
            if (ikConstraints.skin === false) delete (ikConstraints.skin);
            if (ikConstraints.mix === 1) delete (ikConstraints.mix);
            if (ikConstraints.softness === 0) delete (ikConstraints.softness);
            if (ikConstraints.bendPositive === true) delete (ikConstraints.bendPositive);
            if (ikConstraints.compress === false) delete (ikConstraints.compress);
            if (ikConstraints.stretch === false) delete (ikConstraints.stretch);
            if (ikConstraints.uniform === false) delete (ikConstraints.uniform);

            ik[i] = ikConstraints;
        }

        // TRANSFORMS
        this.json.transform = new Array(this.readInt(!![]));
        let transform = this.json.transform;
        for (let i = 0x0; i < transform.length; i++) {
            let transformData = {};
            transformData.name = this.readString();
            transformData.order = this.readInt(!![]);
            transformData.skin = this.readBoolean();
            const bones = new Array(this.readInt(!![]));
            for (let j = 0x0, len = bones.length; j < len; j++) {
                bones[j] = this.json.bones[this.readInt(!![])].name;
            }
            transformData.bones = bones;
            transformData.target = this.json.bones[this.readInt(!![])].name;
            transformData.local = this.readBoolean();
            transformData.relative = this.readBoolean();
            transformData.rotation = this.readFloat();
            transformData['x'] = this.readFloat() * this.scale;
            transformData['y'] = this.readFloat() * this.scale;
            transformData.scaleX = this.readFloat();
            transformData.scaleY = this.readFloat();
            transformData.shearY = this.readFloat();
            transformData.mixRotate = this.readFloat();
            transformData.mixX = this.readFloat();
            transformData.mixY = this.readFloat();
            transformData.mixScaleX = this.readFloat();
            transformData.mixScaleY = this.readFloat();
            transformData.mixShearY = this.readFloat();

            // cleanup keys to match actual exported json


            transform[i] = transformData;
        }

        // PATHS (TO BE VERIFIED)
        this.json.path = new Array(this.readInt(!![]));
        let path = this.json.path;
        for (let i = 0x0; i < path.length; i++) {
            let pathData = {};
            pathData.name = this.readString();
            pathData.order = this.readInt(!![]);
            pathData.skin = this.readBoolean();
            pathData.bones = new Array(this.readInt(!![]));
            for (let j = 0x0, len = pathData.bones.length; j < len; j++) {
                pathData.bones[j] = this.json.bones[this.readInt(!![])].name;
            }
            pathData.target = this.json.slots[this.readInt(!![])].name;
            pathData.positionMode = PositionMode[this.readInt(!![])];
            pathData.spacingMode = SpacingMode[this.readInt(!![])];
            pathData.rotateMode = RotateMode[this.readInt(!![])];
            pathData.rotation = this.readFloat();
            pathData.position = this.readFloat();
            if (pathData.positionMode == 'fixed') {
                pathData.position *= this.scale;
            }
            pathData.spacing = this.readFloat();
            if (pathData.spacingMode == 'length' || pathData.spacingMode == 'fixed') {
                pathData.spacing *= this.scale;
            }
            pathData.rotateMix = this.readFloat();
            pathData.mixX = this.readFloat();
            pathData.mixY = this.readFloat();
            path[i] = pathData;
        }

        // SKINS
        this.json.skins = [];
        let skins = this.json.skins;
        
        // default skin
        let skinData = this.readSkin('default', nonessential);
        if (skinData != null) {
          skins.push(skinData);
        }

        for (let i = 0x0, len = this.readInt(!![]); i < len; i++) {
            let skin = this.readSkin(null, nonessential);
            if(skin != null) {
                skins.push(skin);
            }
        }

        // EVENTS
        this.json.events = {};
        this.eventsName = [];
        let events = this.json.events;
        for (let i = 0x0, len = this.readInt(!![]); i < len; i++) {
            let eventName = this.readStringRef();
            let event = {};
            event.int = this.readInt(![]);
            event.float = this.readFloat();
            event.string = this.readString();
            event.audio = this.readString();
            if(event.audio != null) {
                event.volume = this.readFloat();
                event.balance = this.readFloat();
            }

            // cleanup keys to match actual exported json
            if(event.int === 0) delete(event.int);
            if(event.float === 0) delete(event.float);
            if(event.string === "") delete(event.string);
            if(event.audio === "" || event.audio === null) delete(event.audio);

            events[eventName] = event;
            this.eventsName[i] = eventName;
        }

        // ANIMATIONS
        this.json.animations = {};
        let animations = this.json.animations;
        for (let i = 0x0, len = this.readInt(!![]); i < len; i++) {
            console.log("anim start @ %s", this.nextNum.toString(16))
            let animationName = this.readString();
            let animation = this.readAnimationV4(animationName);
            animations[animationName] = animation;
        }
    },
    readSkin(slotIndex, nonessential) {
        let skin = {};
        let slot = {};
        let slotCount;
        skin.name = slotIndex;

        if(slotIndex !== 'default') {
            skin.name = this.readStringRef();
            // skin.bones
            for(let i = 0, n = this.readInt(!![]); i < n; i++) {
                this.readInt(!![]);
            }
            // skin.ikconstraints
            for(let i = 0, n = this.readInt(!![]); i < n; i++) {
                this.readInt(!![]);
            }
            // skin.transformconstraints
            for(let i = 0, n = this.readInt(!![]); i < n; i++) {
                this.readInt(!![]);
            }
            // skin.pathconstraints
            for(let i = 0, n = this.readInt(!![]); i < n; i++) {
                this.readInt(!![]);
            }
            slotCount = this.readInt(!![]);
        } else {
            slotCount = this.readInt(!![]);
            if (slotCount == 0x0)
                return null;
        }

        skin.attachments = {};
        for (let i = 0x0; i < slotCount; i++) {
            const slotIndex = this.readInt(!![]);
            skin.attachments[this.json.slots[slotIndex].name] = {}
            for (let j = 0x0, n = this.readInt(!![]); j < n; j++) {
                let name = this.readStringRef();
                let attachment = this.readAttachmentV4(slotIndex, name, nonessential);
                if (attachment != null) {
                    slot = attachment;
                }
                skin.attachments[this.json.slots[slotIndex].name][slot.k] = slot.v;
            }
            //skin[this.json.slots[slotIndex].name] = slot;
            //skin.attachments[this.json.slots[slotIndex].name] = slot;   // fix this
        }
        return skin;
    },
    readAttachment(attachmentName, nonessential) {
        let scale = this.scale;
        let name = this.readString();
        if (name == null)
            name = attachmentName;

        let path, n, region = {}, box = {}, mesh = {}, linkdeMesh = {};
        let array;
        let point = {};
        let clipping = {};


        switch (AttachmentType[this.readByte()]) {
            case 'region':
                path = this.readString();
                if (path == null)
                    path = name;
                region.type = 'region';
                region.name = name;
                region.path = path.trim();
                region.rotation = this.readFloat();
                region['x'] = this.readFloat() * scale;
                region['y'] = this.readFloat() * scale;
                region.scaleX = this.readFloat();
                region.scaleY = this.readFloat();
                region.width = this.readFloat() * scale;
                region.height = this.readFloat() * scale;
                region.color = this.readColor();
                return region;
            case 'boundingbox':
                box.type = 'boundingbox';
                box.name = name;
                n = this.readInt(!![]);
                box.vertexCount = n;
                box.vertices = this.readVertices(n);
                if (this.nonessential) {
                    box.color = this.readColor();
                }
                return box;
            case 'mesh':
                path = this.readString();
                if (path == null)
                    path = name;
                mesh.type = 'mesh';
                mesh.name = name;
                mesh.path = path;
                mesh.color = this.readColor();
                n = this.readInt(!![]);
                mesh.uvs = this.readFloatArray(n << 0x1, 0x1);
                mesh.triangles = this.readShortArray();
                mesh.vertices = this.readVertices(n);
                mesh.hull = this.readInt(!![]) << 0x1;
                if (nonessential) {
                    mesh.edges = this.readShortArray();
                    mesh.width = this.readFloat() * scale;
                    mesh.height = this.readFloat() * scale;
                }
                return mesh;
            case 'linkedmesh':
                path = this.readString();
                if (path == null)
                    path = name;
                linkdeMesh.type = 'linkedmesh';
                linkdeMesh.name = name;
                linkdeMesh.path = path;
                linkdeMesh.color = this.readColor();
                linkdeMesh.skin = this.readString();
                linkdeMesh.parent = this.readString();
                linkdeMesh.deform = this.readBoolean();
                if (nonessential) {
                    linkdeMesh.width = this.readFloat() * scale;
                    linkdeMesh.height = this.readFloat() * scale;
                }
                return linkdeMesh;
            case 'path':
                path = {};
                path.type = 'path';
                path.name = name;
                path.closed = this.readBoolean();
                path.constantSpeed = this.readBoolean();
                n = this.readInt(!![]);
                path.vertexCount = n;
                path.vertices = this.readVertices(n);
                array = array = new Array(n / 0x3);
                for (let i = 0x0; i < array.length; i++) {
                    array[i] = this.readFloat() * scale;
                }
                path.lengths = array;
                if (nonessential) {
                    path.color = this.readColor();
                }
                return path;
            case 'point':
                point.type = 'point';
                point.name = name;
                point.rotation = this.readFloat();
                point['x'] = this.readFloat() * scale;
                point['y'] = this.readFloat() * scale;
                if (nonessential) {
                    path.color = this.readColor();
                }
                return point;
            case 'clipping':
                clipping.type = 'clipping';
                clipping.name = name;
                clipping.end = this.readInt(!![]);
                n = this.readInt(!![]);
                clipping.vertexCount = n;
                clipping.vertices = this.readVertices(n);
                if (nonessential) {
                    clipping.color = this.readColor();
                }
                return clipping;
        }
        return null;
    },
    readAttachmentV4(slotIndex, attachmentName, nonessential) {
        let scale = this.scale;
        let name = this.readStringRef();
        if (name == null) name = attachmentName;

        let path, n, region = {}, box = {}, mesh = {}, linkedMesh = {};
        let array;
        let point = {};
        let clipping = {};
        let obj = {}

        switch (AttachmentType[this.readByte()]) {
            // TODO
            case 'region':
                /*
                path = this.readStringRef();
                if (path == null)
                    path = name;
                region.type = 'region';
                //region.name = name;
                region.path = path.trim();
                region.rotation = this.readFloat();
                region['x'] = this.readFloat() * scale;
                region['y'] = this.readFloat() * scale;
                region.scaleX = this.readFloat();
                region.scaleY = this.readFloat();
                region.width = this.readFloat() * scale;
                region.height = this.readFloat() * scale;
                region.color = this.readColor();*/
                console.log("!! UNIMPLEMENTED ATTACHMENT TYPE REGION")
                return region;
            // TODO
            case 'boundingbox':
                /*
                box.type = 'boundingbox';
                box.name = name;
                n = this.readInt(!![]);
                box.vertexCount = n;
                box.vertices = this.readVertices(n);
                if (this.nonessential) {
                    box.color = this.readColor();
                }*/
                console.log("!! UNIMPLEMENTED ATTACHMENT TYPE BOUNDINGBOX")
                return box;
            case 'mesh':
                path = this.readStringRef();
                if (path == null)
                    path = name;
                mesh.type = 'mesh';
                mesh.color = this.readColor();
                n = this.readInt(!![]);
                mesh.uvs = this.readFloatArray(n << 0x1, 0x1);
                mesh.triangles = this.readShortArray();
                let vertices = this.readVertices(n);
                mesh.vertices = vertices.full;
                mesh.numVertices = vertices.numVertices;
                mesh.numBones = vertices.numBones;
                mesh.hull = this.readInt(!![])// << 0x1;
                if (nonessential) {
                    mesh.edges = this.readShortArray();
                    mesh.width = this.readFloat();
                    mesh.height = this.readFloat();
                }

                // cleanup keys to match actual exported json
                if(mesh.color === 'ffffffff') delete(mesh.color);

                obj.k = name;
                obj.v = mesh;
                return obj;
            // TODO
            case 'linkedmesh':
                /*
                path = this.readString();
                if (path == null)
                    path = name;
                linkdeMesh.type = 'linkedmesh';
                linkdeMesh.name = name;
                linkdeMesh.path = path;
                linkdeMesh.color = this.readColor();
                linkdeMesh.skin = this.readString();
                linkdeMesh.parent = this.readString();
                linkdeMesh.deform = this.readBoolean();
                if (nonessential) {
                    linkdeMesh.width = this.readFloat() * scale;
                    linkdeMesh.height = this.readFloat() * scale;
                }*/
                console.log("!! UNIMPLEMENTED ATTACHMENT TYPE LINKEDMESH")
                return linkedMesh;
            // TODO
            case 'path':
                /*
                path = {};
                path.type = 'path';
                path.name = name;
                path.closed = this.readBoolean();
                path.constantSpeed = this.readBoolean();
                n = this.readInt(!![]);
                path.vertexCount = n;
                path.vertices = this.readVertices(n);
                array = array = new Array(n / 0x3);
                for (let i = 0x0; i < array.length; i++) {
                    array[i] = this.readFloat() * scale;
                }
                path.lengths = array;
                if (nonessential) {
                    path.color = this.readColor();
                }*/
                console.log("!! UNIMPLEMENTED ATTACHMENT TYPE PATH")
                return path;
            case 'point':   // FIX THIS
                point.type = 'point';
                point.rotation = this.readFloat();
                point['x'] = this.readFloat() * scale;
                point['y'] = this.readFloat() * scale;
                if (nonessential) {
                    path.color = this.readInt();
                }

                // cleanup keys to match actual exported json
                if(point.rotation === 0) delete(point.rotation);
                if(point['x'] === 0) delete(point['x']);
                if(point['y'] === 0) delete(point['y']);
                //obj[name] = point
                obj.k = name;
                obj.v = point;
                return obj;
            case 'clipping':
                clipping.type = 'clipping';
                clipping.end = this.json.slots[this.readInt(!![])].name
                n = this.readInt(!![]);
                clipping.vertexCount = n;
                clipping.vertices = this.readVertices(n).full;
                if (nonessential) {
                    //clipping.color = this.readColor();
                    this.readInt();
                }
                obj.k = name;
                obj.v = clipping;
                return obj;
            default:
                console.log("!! UNKNOWN ATTACHMENT TYPE")
        }
        return null;
    },
    readCurve1(frameIndex, timeline) {
        let cx1, cy1, cx2, cy2;
        let curveType = this.readByte()
        switch (curveType) {
            case 0x0:
                timeline[frameIndex].curve = 'linear';
                break;
            case 0x1:
                timeline[frameIndex].curve = 'stepped';
                break;
            case 0x2:
                cx1 = this.readFloat();
                cy1 = this.readFloat();
                cx2 = this.readFloat();
                cy2 = this.readFloat();
                timeline[frameIndex].curve = [cx1, cy1, cx2, cy2];
        }
    },
    readCurve2(frameIndex, timeline) {
        let cx1, cy1, cx2, cy2, cx3, cy3, cx4, cy4;
        let curveType = this.readByte()
        switch (curveType) {
            case 0x0:
                timeline[frameIndex].curve = 'linear';
                break;
            case 0x1:
                timeline[frameIndex].curve = 'stepped';
                break;
            case 0x2:
                cx1 = this.readFloat();
                cy1 = this.readFloat();
                cx2 = this.readFloat();
                cy2 = this.readFloat();
                cx3 = this.readFloat();
                cy3 = this.readFloat();
                cx4 = this.readFloat();
                cy4 = this.readFloat();
                timeline[frameIndex].curve = [cx1, cy1, cx2, cy2, cx3, cy3, cx4, cy4];
        }
    },
    readCurveN(frameIndex, timeline, readCount) {
        let curveType = this.readByte()
        switch (curveType) {
            case 0x0:
                timeline[frameIndex].curve = 'linear';
                break;
            case 0x1:
                timeline[frameIndex].curve = 'stepped';
                break;
            case 0x2:
                timeline[frameIndex].curve = []
                for(let i = 0; i < readCount; i++) {
                    timeline[frameIndex].curve.push(this.readFloat());  // x1
                    timeline[frameIndex].curve.push(this.readFloat());  // x2
                    timeline[frameIndex].curve.push(this.readFloat());  // y1
                    timeline[frameIndex].curve.push(this.readFloat());  // y2
                }
                break;
        }
    },
    readAnimation(name) {
        let animation = {};
        let scale = this.scale;
        let duration = 0x0;
        let slots = {};
        for (let i = 0x0, nn = this.readInt(!![]); i < nn; i++) {
            let slotIndex = this.readInt(!![]);
            let slotMap = {};
            let timeCount = this.readInt(!![]);
            for (let ii = 0x0; ii < timeCount; ii++) {
                let timelineType = this.readByte();
                let frameCount = this.readInt(!![]);
                let timeline;
                switch (timelineType) {
                    case 0x0:
                        timeline = new Array(frameCount);
                        for (let frameIndex = 0x0; frameIndex < frameCount; frameIndex++) {
                            let time = this.readFloat();
                            let color = this.readString();
                            timeline[frameIndex] = {};
                            timeline[frameIndex].time = time;
                            timeline[frameIndex].name = color;
                        }
                        slotMap.attachment = timeline;
                        duration = Math.max(duration, timeline[frameCount - 0x1].time);
                        break;
                    case 0x1:
                        timeline = new Array(frameCount);
                        for (let frameIndex = 0x0; frameIndex < frameCount; frameIndex++) {
                            const time = this.readFloat();
                            const color = this.readColor();
                            timeline[frameIndex] = {};
                            timeline[frameIndex].time = time;
                            timeline[frameIndex].color = color;
                            if (frameIndex < frameCount - 0x1) {
                                this.readCurve(frameIndex, timeline); //let curve 
                            }
                        }
                        slotMap.color = timeline;
                        duration = Math.max(duration, timeline[frameCount - 0x1].time);
                        break;
                    case 0x2:
                        timeline = new Array(frameCount);
                        for (let frameIndex = 0x0; frameIndex < frameCount; frameIndex++) {
                            const time = this.readFloat();
                            let lightColor = this.readColor();
                            let darkColor = this.readColor();
                            timeline[frameIndex] = {};
                            timeline[frameIndex].time = time;
                            timeline[frameIndex].light = lightColor;
                            timeline[frameIndex].dark = darkColor;
                            if (frameIndex < frameCount - 0x1) {
                                this.readCurve(frameIndex, timeline);// let curve
                            }
                        }
                        slotMap.twoColor = timeline;
                        duration = Math.max(duration, timeline[frameCount - 0x1].time);
                        break;
                }
            }
            slots[this.json.slots[slotIndex].name] = slotMap;
        }
        animation.slots = slots;
        let bones = {};
        for (let i = 0x0, n = this.readInt(!![]); i < n; i++) {
            let boneIndex = this.readInt(!![]);
            let boneMap = {};
            for (let ii = 0x0, nn = this.readInt(!![]); ii < nn; ii++) {
                const timelineType = this.readByte();
                const frameCount = this.readInt(!![]);
                let timeline;
                let timelineScale = 0x1;

                switch (timelineType) {
                    case 0x0:
                        timeline = new Array(frameCount);
                        for (let frameIndex = 0x0; frameIndex < frameCount; frameIndex++) {
                            const time = this.readFloat();
                            const tlangle = this.readFloat();
                            timeline[frameIndex] = {};
                            timeline[frameIndex].time = time;
                            timeline[frameIndex].angle = tlangle;
                            if (frameIndex < frameCount - 0x1) {
                                this.readCurve(frameIndex, timeline);
                            }
                        }
                        boneMap.rotate = timeline;
                        duration = Math.max(duration, timeline[frameCount - 0x1].time);
                        break;
                    case 0x1:
                    case 0x2:
                    case 0x3:
                        timeline = new Array(frameCount);
                        if (timelineType == 0x1) {
                            timelineScale = scale;
                        }
                        for (let frameIndex = 0x0; frameIndex < frameCount; frameIndex++) {
                            let tltime = this.readFloat();
                            let tlx = this.readFloat();
                            let tly = this.readFloat();
                            timeline[frameIndex] = {};
                            timeline[frameIndex].time = tltime;
                            timeline[frameIndex]['x'] = tlx * timelineScale;
                            timeline[frameIndex]['y'] = tly * timelineScale;
                            if (frameIndex < frameCount - 0x1) {
                                this.readCurve(frameIndex, timeline);
                            }
                        }
                        if (timelineType == 0x1) {
                            boneMap.translate = timeline;
                        } else if (timelineType == 0x2) {
                            boneMap.scale = timeline;
                        } else {
                            boneMap.shear = timeline;
                        }
                        duration = Math.max(duration, timeline[frameCount - 0x1].time);
                        break;
                }
            }
            bones[this.json.bones[boneIndex].name] = boneMap;
        }
        animation.bones = bones;
        let ik = {};
        for (let i = 0x0, nn = this.readInt(!![]); i < nn; i++) {
            const ikIndex = this.readInt(!![]);
            const frameCount = this.readInt(!![]);
            const timeline = new Array(frameCount);
            for (let frameIndex = 0x0; frameIndex < frameCount; frameIndex++) {
                const time = this.readFloat();
                const mix = this.readFloat();
                const bendPositive = this.readByte() != 0xff;
                timeline[frameIndex] = {};
                timeline[frameIndex].time = time;
                timeline[frameIndex].mix = mix;
                timeline[frameIndex].bendPositive = bendPositive;
                if (frameIndex < frameCount - 0x1) {
                    this.readCurve(frameIndex, timeline);
                }
            }
            ik[this.json['ik'][ikIndex].name] = timeline;
            duration = Math.max(duration, timeline[frameCount - 0x1].time);
        }
        animation['ik'] = ik;
        let ffd = {};
        for (let i = 0x0, nn = this.readInt(!![]); i < nn; i++) {
            const slotIndex = this.readInt(!![]);
            const frameCount = this.readInt(!![]);
            const timeline = new Array(frameCount);
            for (let frameIndex = 0x0; frameIndex < frameCount; frameIndex++) {
                timeline[frameIndex] = {};
                timeline[frameIndex].time = this.readFloat();
                timeline[frameIndex].rotateMix = this.readFloat();
                timeline[frameIndex].translateMix = this.readFloat();
                timeline[frameIndex].scaleMix = this.readFloat();
                timeline[frameIndex].shearMix = this.readFloat();
                if (frameIndex < frameCount - 0x1) {
                    this.readCurve(frameIndex, timeline);
                }
            }
            ffd[this.json.transform[slotIndex].name] = timeline;
            duration = Math.max(duration, timeline[frameCount - 0x1].time);
        }
        animation.transform = ffd;

        let path = {};
        for (let i = 0x0, n = this.readInt(!![]); i < n; i++) {
            let pathOrder = this.readInt(!![]);
            let pathData = this.json.path[pathOrder];
            let data = {};
            for (let ii = 0x0, nn = this.readInt(!![]); ii < nn; ii++) {
                const timelineType = this.readByte();
                const frameCount = this.readInt(!![]);
                let timeline, time, timelineScale;
                switch (timelineType) {
                    case 0x0:
                    case 0x1:
                        timeline = new Array(frameCount);
                        timelineScale = 0x1;
                        if (timelineType == 0x1) {
                            if (pathData.spacingMode == 'length' || pathData.spacingMode == 'fixed') {
                                timelineScale = this.scale;
                            }
                        } else {
                            if (pathData.positionMode == 'fixed') {
                                timelineScale = this.scale;
                            }
                        }
                        for (let frameIndex = 0x0; frameIndex < frameCount; frameIndex++) {
                            time = this.readFloat();
                            let _0xebc795 = this.readFloat();
                            timeline[frameIndex] = {};
                            timeline[frameIndex].time = time;
                            if (timelineType == 0x0) {
                                timeline[frameIndex].position = _0xebc795 * timelineScale;
                            } else {
                                timeline[frameIndex].spacing = _0xebc795 * timelineScale;
                            }
                            if (frameIndex < frameCount - 0x1)
                                this.readCurve(frameIndex, timeline);
                        }
                        if (timelineType == 0x0) {
                            data.position = timeline;
                        } else {
                            data.spacing = timeline;
                        }
                        duration = Math.max(duration, timeline[frameCount - 0x1].time);
                        break;
                    case 0x2:
                        timeline = new Array(frameCount);
                        for (let frameIndex = 0x0; frameIndex < frameCount; frameIndex++) {
                            time = this.readFloat();
                            let _0x47f0f0 = this.readFloat();
                            let _0x1bb1d7 = this.readFloat();
                            timeline[frameIndex] = {};
                            timeline[frameIndex].time = time;
                            timeline[frameIndex].rotateMix = _0x47f0f0;
                            timeline[frameIndex].translateMix = _0x1bb1d7;
                            if (frameIndex < frameCount - 0x1)
                                this.readCurve(frameIndex, timeline);
                        }
                        data.mix = timeline;
                        duration = Math.max(duration, timeline[frameCount - 0x1].time);
                        break;
                }
            }
            path[this.json.path[pathOrder].name] = data;
        }
        animation.paths = path;

        // 变量名可能不对
        let deform = {};
        for (let i = 0x0, n = this.readInt(!![]); i < n; i++) {
            let index = this.readInt(!![]);
            let skinName = this.json.skinsName[index];
            let deformData = {};
            for (let ii = 0x0, nn = this.readInt(!![]); ii < nn; ii++) {
                const slotIndex = this.readInt(!![]);
                const slot = this.json.slots[slotIndex];
                const attachment = {};
                for (let iii = 0x0, nnn = this.readInt(!![]); iii < nnn; iii++) {
                    const name = this.readString();
                    const frameCount = this.readInt(!![]);
                    const timeline = new Array(frameCount);
                    for (let frameIndex = 0x0; frameIndex < frameCount; frameIndex++) {
                        const time = this.readFloat();
                        const end = this.readInt(!![]);
                        timeline[frameIndex] = {};
                        timeline[frameIndex].time = time;
                        if (end != 0x0) {
                            let vertices = new Array(end);
                            let start = this.readInt(!![]);
                            if (this.scale == 0x1) {
                                for (let i = 0x0; i < end; i++) {
                                    vertices[i] = this.readFloat();
                                }
                            } else {
                                for (let i = 0x0; i < end; i++) {
                                    vertices[i] = this.readFloat() * this.scale;
                                }
                            }
                            timeline[frameIndex].offset = start;
                            timeline[frameIndex].vertices = vertices;
                        }
                        if (frameIndex < frameCount - 0x1)
                            this.readCurve(frameIndex, timeline);
                    }
                    attachment[name] = timeline;
                    duration = Math.max(duration, timeline[frameCount - 0x1].time);
                }
                deformData[slot.name] = attachment;
            }
            deform[skinName] = deformData;
        }
        animation.deform = deform;

        let drawOrderCount = this.readInt(!![]);
        if (drawOrderCount > 0x0) {
            let drawOrders = new Array(drawOrderCount);
            for (let i = 0x0; i < drawOrderCount; i++) {
                const drawOrderMap = {};
                const time = this.readFloat();
                const offsetCount = this.readInt(!![]);
                const offsets = new Array(offsetCount);
                for (let ii = 0x0; ii < offsetCount; ii++) {
                    const offsetMap = {};
                    const slotIndex = this.readInt(!![]);
                    offsetMap.slot = this.json.slots[slotIndex].name;
                    let dooffset = this.readInt(!![]);
                    offsetMap.offset = dooffset;
                    offsets[ii] = offsetMap;
                }
                drawOrderMap.offsets = offsets;
                drawOrderMap.time = time;
                drawOrders[i] = drawOrderMap;
            }
            duration = Math.max(duration, drawOrders[drawOrderCount - 0x1].time);
            animation.drawOrder = drawOrders;
        }
        let eventCount = this.readInt(!![]);
        if (eventCount > 0x0) {
            let events = new Array(eventCount);
            for (let i = 0x0; i < eventCount; i++) {
                const time = this.readFloat();
                const name = this.json.eventsName[this.readInt(!![])];
                const eventData = this.json.events[name];
                const e = {};
                e.name = name;
                e.int = this.readInt(![]);
                e.float = this.readFloat();
                e.string = this.readBoolean() ? this.readString() : eventData.string;
                e.time = time;
                events[i] = e;
            }
            duration = Math.max(duration, events[eventCount - 0x1].time);
            animation.events = events;
        }
        return animation;
    },
    readTimeline1(frameCount) {
        let timeline = new Array(frameCount)
        let t1 = this.readFloat();
        let v1 = this.readFloat() * this.scale;
        for (let frameIndex = 0; frameIndex < frameCount - 1; frameIndex++) {
            if(frameIndex == frameCount) break;
            timeline[frameIndex] = {};
            let t2 = this.readFloat();
            let v2 = this.readFloat() * this.scale;
            this.readCurve1(frameIndex, timeline)
            timeline[frameIndex].time = t1
            timeline[frameIndex]["value"] = v1;
            t1 = t2
            v1 = v2

            // cleanup keys to match exported json
            if(timeline[frameIndex].time === 0) delete(timeline[frameIndex].time);
            if(timeline[frameIndex].value === 0) delete(timeline[frameIndex].value);
        }

        let lastFrame = frameCount - 1
        timeline[lastFrame] = {};
        timeline[lastFrame].time = t1;
        timeline[lastFrame]["value"] = v1;

        // cleanup keys to match exported json
        if(timeline[lastFrame].time === 0) delete(timeline[lastFrame].time);
        if(timeline[lastFrame].value === 0) delete(timeline[lastFrame].value);

        return timeline;
    },
    readTimeline2(frameCount) {
        let timeline = new Array(frameCount)
        let t1 = this.readFloat();
        let v1 = this.readFloat() * this.scale;
        let v2 = this.readFloat() * this.scale;
        for(let frameIndex = 0; frameIndex < frameCount - 1; frameIndex++) {
            if(frameIndex == frameCount) break;
            timeline[frameIndex] = {};
            let t2 = this.readFloat();
            let nv1 = this.readFloat() * this.scale;
            let nv2 = this.readFloat() * this.scale;
            this.readCurve2(frameIndex, timeline)
            timeline[frameIndex].time = t1;
            timeline[frameIndex]['x'] = v1;
            timeline[frameIndex]['y'] = v2;
            t1 = t2;
            v1 = nv1;
            v2 = nv2;

            // cleanup keys to match exported json
            if(timeline[frameIndex].time === 0) delete(timeline[frameIndex].time);
            if(timeline[frameIndex].x === 0) delete(timeline[frameIndex].x);
            if(timeline[frameIndex].y === 0) delete(timeline[frameIndex].y);
        }

        let lastFrame = frameCount - 1
        timeline[frameCount - 1] = {}
        timeline[frameCount - 1].time = t1;
        timeline[frameCount - 1]['x'] = v1;
        timeline[frameCount - 1]['y'] = v2;

        // cleanup keys to match exported json
        if(timeline[lastFrame].time === 0) delete(timeline[lastFrame].time);
        if(timeline[lastFrame].x === 0) delete(timeline[lastFrame].x);
        if(timeline[lastFrame].y === 0) delete(timeline[lastFrame].y);

        return timeline;
    },
    readAnimationV4(name) {
        let animation = {};
        let scale = this.scale;
        let duration = 0x0;
        let slots = {};
        let nTimelines = this.readInt(!![]);
        let bezierCount, time, color1, color2;

        console.log("=== READ ANIMATION START: %s ===", name)

        // slot timelines
        console.log("\tslot start @ %s", this.nextNum.toString(16))
        for (let i = 0x0, nn = this.readInt(!![]); i < nn; i++) {
            let slotIndex = this.readInt(!![]);
            let slotMap = {};
            let timeCount = this.readInt(!![]);

            console.log("\tslotname: %s (%d)", this.json.slots[slotIndex].name, slotIndex)

            for (let ii = 0x0; ii < timeCount; ii++) {
                let timelineType = this.readByte();
                let frameCount = this.readInt(!![]);
                let timeline;
                //console.log("slot timeline type: %d | framecount: %d | num: %d", timelineType, frameCount, this.nextNum)
                switch (timelineType) {
                    case 0x0:   // SLOT_ATTACHMENT
                        timeline = new Array(frameCount);
                        for (let frameIndex = 0x0; frameIndex < frameCount; frameIndex++) {
                            let time = this.readFloat();
                            let attachmentName = this.readStringRef();
                            timeline[frameIndex] = {};
                            timeline[frameIndex].time = time;
                            timeline[frameIndex].name = attachmentName;
                        }
                        slotMap.attachment = timeline;
                        break;
                    case 0x1:   // SLOT_RGBA
                        timeline = new Array(frameCount);
                        bezierCount = this.readInt(!![]);
                        time = this.readFloat()
                        color1 = this.readColor();

                        for (let frameIndex = 0x0; frameIndex < frameCount; frameIndex++) {
                            timeline[frameIndex] = {};
                            timeline[frameIndex].time = time;
                            timeline[frameIndex].color = color1;
                            if(frameIndex == frameCount-1) break;
                            let time2 = this.readFloat();
                            color2 = this.readColor();
                            this.readCurveN(frameIndex, timeline, 4);
                            time = time2;
                            color1 = color2;
                        }
                        slotMap.rgba = timeline;
                        break;
                    case 0x2:   // SLOT_RGB (TODO)
                        timeline = new Array(frameCount);
                        for (let frameIndex = 0x0; frameIndex < frameCount; frameIndex++) {
                            const time = this.readFloat();
                            let lightColor = this.readColor();
                            let darkColor = this.readColor();
                            timeline[frameIndex] = {};
                            timeline[frameIndex].time = time;
                            timeline[frameIndex].light = lightColor;
                            timeline[frameIndex].dark = darkColor;
                            if (frameIndex < frameCount - 0x1) {
                                this.readCurve(frameIndex, timeline);// let curve // read 8 curve
                            }
                        }
                        slotMap.twoColor = timeline;
                        break;
                    default:
                        console.log("unknown slot timeline type: %d", timelineType)
                        break;
                }
            }
            slots[this.json.slots[slotIndex].name] = slotMap;
        }
        animation.slots = slots;

        // bone timelines
        let bones = {};
        console.log("\tbone start @ %s", this.nextNum.toString(16))
        for (let i = 0x0, n = this.readInt(!![]); i < n; i++) {
            let boneIndex = this.readInt(!![]);
            let boneMap = {};
            //console.log("\t\tread bone: %s (%d/%d)", this.json.bones[boneIndex].name, i, n)
            for (let ii = 0x0, nn = this.readInt(!![]); ii < nn; ii++) {
                const timelineType = this.readByte();
                const frameCount = this.readInt(!![]);
                const bezierCount = this.readInt(!![]);
                let timeline;
                let timelineScale = 0x1;
                
                switch (timelineType) {
                    case 0x0:   // rotate
                        timeline = this.readTimeline1(frameCount);
                        boneMap.rotate = timeline;
                        break;
                    case 0x1:   // translate
                        timeline = this.readTimeline2(frameCount);
                        boneMap.translate = timeline;
                        break;
                    case 0x2:   // translate X
                        timeline = this.readTimeline1(frameCount);
                        boneMap.translatex = timeline;
                        break;
                    case 0x3:   // translate Y
                        timeline = this.readTimeline1(frameCount);
                        boneMap.translatey = timeline;
                        break;
                    case 0x4:   // scale
                        timeline = this.readTimeline2(frameCount);
                        boneMap.scale = timeline;
                        break;
                    case 0x5:   // scale X
                        timeline = this.readTimeline1(frameCount);
                        boneMap.scalex = timeline;
                        break;
                    case 0x6:   // scale Y
                        timeline = this.readTimeline1(frameCount);
                        boneMap.scaley = timeline;
                        break;
                    case 0x7:   // shear
                        timeline = this.readTimeline2(frameCount);
                        boneMap.shear = timeline;
                        break;
                    case 0x8:   // shear X
                        timeline = this.readTimeline1(frameCount);
                        boneMap.shearx = timeline;
                        break;
                    case 0x9:   // shear Y
                        timeline = this.readTimeline1(frameCount);
                        boneMap.sheary = timeline;
                        break;
                    default:
                        console.log("unknown bone timeline type %s", timelineType.toString(16));
                        break;
                }
            }
            bones[this.json.bones[boneIndex].name] = boneMap;
        }
        animation.bones = bones;

        // ik timelines
        let ik = {};
        console.log("\tik start @ %s", this.nextNum.toString(16))
        for (let i = 0x0, nn = this.readInt(!![]); i < nn; i++) {
            const ikIndex = this.readInt(!![]);
            const frameCount = this.readInt(!![]);
            const bezierCount = this.readInt(!![]);

            let time = this.readFloat();
            let mix = this.readFloat();
            let softness = this.readFloat() * this.scale;

            const timeline = new Array(frameCount);
            for (let frameIndex = 0; frameIndex < frameCount; frameIndex++) {
                const bendPositive = this.readByte() != 0xff;
                const compress = this.readBoolean();
                const stretch = this.readBoolean();

                timeline[frameIndex] = {};
                timeline[frameIndex].time = time;
                timeline[frameIndex].mix = mix;
                timeline[frameIndex].softness = softness;
                timeline[frameIndex].bendPositive = bendPositive;
                timeline[frameIndex].compress = compress;
                timeline[frameIndex].stretch = stretch;

                
                // cleanup keys to match actual exported json
                if(timeline[frameIndex].time === 0) delete(timeline[frameIndex].time);
                if(timeline[frameIndex].mix === 1) delete(timeline[frameIndex].mix);
                if(timeline[frameIndex].softness === 0) delete(timeline[frameIndex].softness);
                if(timeline[frameIndex].bendPositive === true) delete(timeline[frameIndex].bendPositive);
                if(timeline[frameIndex].compress === true) delete(timeline[frameIndex].compress);
                if(timeline[frameIndex].stretch === false) delete(timeline[frameIndex].stretch);

                if(frameIndex == frameCount - 1) break;
                const time2 = this.readFloat();
                const mix2 = this.readFloat();
                const softness2 = this.readFloat() * scale;
                this.readCurveN(frameIndex, timeline, 2);
                time = time2;
                mix = mix2;
                softness = softness2;
            }
            ik[this.json['ik'][ikIndex].name] = timeline;
        }
        animation['ik'] = ik;

        // transform constraint timelines
        let transforms = {};
        console.log("\ttransform start @ %s", this.nextNum.toString(16))
        for (let i = 0x0, nn = this.readInt(!![]); i < nn; i++) {
            const slotIndex = this.readInt(!![]);
            const frameCount = this.readInt(!![]);
            const bezierCount = this.readInt(!![]);
            const timeline = new Array(frameCount);

            let time = this.readFloat();
            let mixRotate = this.readFloat();
            let mixX = this.readFloat();
            let mixY = this.readFloat();
            let mixScaleX = this.readFloat();
            let mixScaleY = this.readFloat();
            let mixShearY = this.readFloat();
            for (let frameIndex = 0x0; frameIndex < frameCount; frameIndex++) {
                timeline[frameIndex] = {};
                timeline[frameIndex].time = time;
                timeline[frameIndex].mixRotate = mixRotate;
                timeline[frameIndex].mixX = mixX;
                timeline[frameIndex].mixY = mixY;
                timeline[frameIndex].mixScaleX = mixScaleX;
                timeline[frameIndex].mixScaleY = mixScaleY;
                timeline[frameIndex].mixShearY = mixShearY;
                if(frameIndex == frameCount - 1) break;
                let time2 = this.readFloat();
                let mixRotate2 = this.readFloat();
                let mixX2 = this.readFloat();
                let mixY2 = this.readFloat();
                let mixScaleX2 = this.readFloat();
                let mixScaleY2 = this.readFloat();
                let mixShearY2 = this.readFloat();
                this.readCurveN(frameIndex, timeline, 6);
                time = time2;
                mixRotate = mixRotate2;
                mixX = mixX2;
                mixY = mixY2;
                mixScaleX = mixScaleX2;
                mixScaleY = mixScaleY2;
                mixShearY = mixShearY2;
            }
            /*
            for (let frameIndex = 0x0; frameIndex < frameCount; frameIndex++) {
                timeline[frameIndex] = {};
                timeline[frameIndex].time = this.readFloat();
                timeline[frameIndex].rotateMix = this.readFloat();
                timeline[frameIndex].translateMix = this.readFloat();
                timeline[frameIndex].scaleMix = this.readFloat();
                timeline[frameIndex].shearMix = this.readFloat();
                if (frameIndex < frameCount - 0x1) {
                    this.readCurve(frameIndex, timeline);
                }
            }*/
            transforms[this.json.transform[slotIndex].name] = timeline;
        }
        animation.transform = transforms;

        // path constraint timelines (TO BE VERIFIED)
        let path = {};
        console.log("\tpath start @ %s", this.nextNum.toString(16))
        for (let i = 0x0, n = this.readInt(!![]); i < n; i++) {
            let pathOrder = this.readInt(!![]);
            let pathData = this.json.path[pathOrder];
            let data = {};
            for (let ii = 0x0, nn = this.readInt(!![]); ii < nn; ii++) {
                const timelineType = this.readByte();
                const frameCount = this.readInt(!![]);
                let timeline, time, timelineScale;
                switch (timelineType) {
                    case 0x0:
                    case 0x1:
                        timeline = new Array(frameCount);
                        timelineScale = 0x1;
                        if (timelineType == 0x1) {
                            if (pathData.spacingMode == 'length' || pathData.spacingMode == 'fixed') {
                                timelineScale = this.scale;
                            }
                        } else {
                            if (pathData.positionMode == 'fixed') {
                                timelineScale = this.scale;
                            }
                        }
                        for (let frameIndex = 0x0; frameIndex < frameCount; frameIndex++) {
                            time = this.readFloat();
                            let _0xebc795 = this.readFloat();
                            timeline[frameIndex] = {};
                            timeline[frameIndex].time = time;
                            if (timelineType == 0x0) {
                                timeline[frameIndex].position = _0xebc795 * timelineScale;
                            } else {
                                timeline[frameIndex].spacing = _0xebc795 * timelineScale;
                            }
                            if (frameIndex < frameCount - 0x1)
                                this.readCurve(frameIndex, timeline);
                        }
                        if (timelineType == 0x0) {
                            data.position = timeline;
                        } else {
                            data.spacing = timeline;
                        }
                        duration = Math.max(duration, timeline[frameCount - 0x1].time);
                        break;
                    case 0x2:
                        timeline = new Array(frameCount);
                        for (let frameIndex = 0x0; frameIndex < frameCount; frameIndex++) {
                            time = this.readFloat();
                            let _0x47f0f0 = this.readFloat();
                            let _0x1bb1d7 = this.readFloat();
                            timeline[frameIndex] = {};
                            timeline[frameIndex].time = time;
                            timeline[frameIndex].rotateMix = _0x47f0f0;
                            timeline[frameIndex].translateMix = _0x1bb1d7;
                            if (frameIndex < frameCount - 0x1)
                                this.readCurve(frameIndex, timeline);
                        }
                        data.mix = timeline;
                        duration = Math.max(duration, timeline[frameCount - 0x1].time);
                        break;
                }
            }
            path[this.json.path[pathOrder].name] = data;
        }
        animation.paths = path;

        // deform timelines
        let deform = {};
        console.log("\tdeform start @ %s", this.nextNum.toString(16))
        for (let i = 0x0, n = this.readInt(!![]); i < n; i++) {
            let index = this.readInt(!![]);
            let skinName = this.json.skins[index].name;
            let deformData = {};
            for (let ii = 0x0, nn = this.readInt(!![]); ii < nn; ii++) {
                const slotIndex = this.readInt(!![]);
                const slot = this.json.slots[slotIndex];
                const attachment = {};
                let defAttachment = {};
                for (let iii = 0x0, nnn = this.readInt(!![]); iii < nnn; iii++) {
                    const attachmentName = this.readStringRef();
                    let attachments = Object.entries(this.json.skins[index].attachments);
                    attachments.forEach(a => {
                        let aa = Object.keys(a[1]);
                        for(let ax = 0; ax < aa.length; ax++) {
                            if(aa[ax] === attachmentName) {
                                defAttachment = a[1][attachmentName];
                                break;
                            }
                        }
                    });
                    const frameCount = this.readInt(!![]);
                    const bezierCount = this.readInt(!![]);  // ok

                    const timeline = new Array(frameCount);
                    const weighted = 'vertices' in defAttachment;
                    const deformLength = weighted ? (defAttachment.numVertices / 3) << 1 : defAttachment.numVertices;

                    let time = this.readFloat();
                    for(let frameIndex = 0; frameIndex < frameCount; frameIndex++) {
                        timeline[frameIndex] = {};
                        let end = this.readInt(!![]);
                        let start, deform;
                        if(end != 0) {
                            deform = new Array(deformLength);
                            start = this.readInt(!![]);
                            end += start;
                            if(scale == 1) {
                                for(let v = start; v < end; v++)
                                    deform[v] = this.readFloat();
                            } else {
                                for(let v = start; v < end; v++)
                                    deform[v] = this.readFloat() * this.scale;
                            }
                            //end += start;
                            deform = deform.filter(element => {
                                return element !== null;
                            });
                            timeline[frameIndex].offset = start;
                            timeline[frameIndex].vertices = deform;
                        }
                        timeline[frameIndex].time = time;
                        
                        // cleanup keys to match exported json
                        if(timeline[frameIndex].offset === 0) delete(timeline[frameIndex].offset);
                        if(timeline[frameIndex].time === 0) delete(timeline[frameIndex].time);

                        if(frameIndex == frameCount-1) break;
                        let time2 = this.readFloat();
                        this.readCurve1(frameIndex, timeline);
                        if(timeline[frameIndex].curve === "linear") delete(timeline[frameIndex].curve);

                        time = time2;
                    }

                    attachment[attachmentName] = timeline;
                }
                deformData[slot.name] = attachment;
            }
            deform[skinName] = deformData;
        }
        animation.deform = deform;

        // draw order timelines (TO BE VERIFIED)
        let drawOrderCount = this.readInt(!![]);
        if (drawOrderCount > 0x0) {
            let drawOrders = new Array(drawOrderCount);
            for (let i = 0x0; i < drawOrderCount; i++) {
                const drawOrderMap = {};
                const time = this.readFloat();
                const offsetCount = this.readInt(!![]);
                const offsets = new Array(offsetCount);
                for (let ii = 0x0; ii < offsetCount; ii++) {
                    const offsetMap = {};
                    const slotIndex = this.readInt(!![]);
                    offsetMap.slot = this.json.slots[slotIndex].name;
                    let dooffset = this.readInt(!![]);
                    offsetMap.offset = dooffset;
                    offsets[ii] = offsetMap;
                }
                drawOrderMap.offsets = offsets;
                drawOrderMap.time = time;
                drawOrders[i] = drawOrderMap;
            }
            animation.drawOrder = drawOrders;
        }

        // event timelines
        let eventCount = this.readInt(!![]);
        if (eventCount > 0x0) {
            let events = new Array(eventCount);
            for (let i = 0x0; i < eventCount; i++) {
                const time = this.readFloat();
                //const name = this.json.eventsName[this.readInt(!![])];
                const name = this.eventsName[this.readInt(!![])]
                const eventData = this.json.events[name];
                const e = {};
                e.name = name;
                e.int = this.readInt(![]);
                e.float = this.readFloat();
                e.string = this.readBoolean() ? this.readString() : eventData.string;
                e.time = time;

                // cleanup keys to match actual exported json
                if(e.int === 0) delete(e.int);
                if(e.float === 0) delete(e.float);
                if(e.string === "") delete(e.string);

                events[i] = e;
            }
            animation.events = events;
        }

        // cleanup keys to match actual exported json
        if(Object.keys(animation.slots).length === 0) delete(animation.slots);
        if(Object.keys(animation.bones).length === 0) delete(animation.bones);
        if(Object.keys(animation.ik).length === 0) delete(animation.ik);
        if(Object.keys(animation.transform).length === 0) delete(animation.transform);
        if(Object.keys(animation.paths).length === 0) delete(animation.paths);
        if(Object.keys(animation.deform).length === 0) delete(animation.deform);

        return animation;
    }
};

const skel2Json = binary => {
    console.log("SKEL2JSON for 4.0.47/62! Ported by FZFalzar")
    const skel_bin = new SkeletonBinary();
    skel_bin.data = new Uint8Array(binary);
    skel_bin.initJson();
    return skel_bin.json;
};

export default skel2Json;